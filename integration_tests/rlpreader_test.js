const assert = require('assert');
const path = require('path');
const util = require('./utils');
const async = require('async');

var rlpreadertest;

const bytecode = "60606040526108df806100126000396000f3606060405236156100615760e060020a600035046304455e9581146100635780630d9fda6914610163578063564ad142146101f2578063710e00f814610264578063b5e0d64a14610298578063c483922b146102fd578063d572056e14610355575b005b6103c16004808035906020019082018035906020019191908080601f0160208091040260200160405190810160405280939291908181526020018383808284375094965050505050505060006104a76104af835b6040805160a081018252600080825260208281018290529282018190526060820181905260808201529082016104b9815b60a060405190810160405280600081526020016000815260200160008152602001600081526020016000815260200150600060006000600060006000875160001a9550608086101561073e576040805160a0810182528981526001602082015290810182905260608101829052608081018290529650610733565b60408051602060248035600481810135601f81018590048502860185019096528585526103d3958135959194604494929390920191819084018382808284375094965050933593505050506040805160208101909152600081526104b98484845b60006020601f83010484602085015b8284146105f957602084028083015181830152600185019450506101d3565b6104416004808035906020019082018035906020019191908080601f016020809104026020016040519081016040528093929190818152602001838380828437509496505093359350505050604080516020810190915260008082529081908190816104c06104d3876105628a6100b7565b6103c160043560243560006104b983835b815160019283015160009190911a9190910360208190036101000a909104010190565b6103d36004808035906020019082018035906020019191908080601f016020809104026020016040519081016040528093929190818152602001838380828437509496505050505050506040805160208101909152600081526105a96105b0836100b7565b6103c16004808035906020019082018035906020019191908080601f0160208091040260200160405190810160405280939291908181526020018383808284375094965050505050505060006105a96105dd836100b7565b6104416004808035906020019082018035906020019191908080601f01602080910402602001604051908101604052809392919081815260200183838082843750949650505050505050604080516020810190915260008082529081908190816105e76104d3876100b7565b60408051918252519081900360200190f35b60405180806020018281038252838181518152602001915080519060200190808383829060006004602084601f0104600f02600301f150905090810190601f1680156104335780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b60405180868152602001858152602001848152602001806020018381526020018281038252848181518152602001915080519060200190602002808383829060006004602084601f0104600f02600301f150905001965050505050505060405180910390f35b90505b919050565b60408101516104aa565b9392505050565b939b929a50909850965090945092505050565b604080516020818101835260008083528451918501519385015191939290808080851561062d5760405160808a0151945084908059106105105750595b8181526020918202810190910160405260608a01519095509250600091505b8382101561062d57602082028301519050808583815181101561000257602090810290910101526001919091019061052f565b9060a0604051908101604052806000815260200160008152602001600081526020016000815260200160008152602001506000600084602001518410151561060c57610002565b90506104aa565b60206040519081016040528060008152602001506000600060006000600086604001511561063957610002565b60808101516104aa565b939a9299509097509550909350915050565b6000865160200187015250505050505050565b505060608301516020830281015190610624826100e8565b95945050505050565b50505091939590929450565b8651805160001a94509250608084101561069a57600160405180591061065c5750595b9080825280602002602001820160405250955085508360f860020a0286600081518110156100025782901a90506020880153505b5050505050919050565b60b88410156106b95760208701516000190194506001830191506106d5565b5050602085015182900360b601925081810160b5190160b61983015b846040518059106106e35750595b8181526020918202810190910160405295506106908287876101c4565b6020848102860160a0810160409081528a8252918101859052600191810191909152606081018690526080810185905296505b505050505050919050565b60b886101561077c576040805160a081018252898152607e198801602082015260009181018290526060810182905260808101919091529650610733565b60c08610156107a25760a0604051908101604052808981526020016107dd8a60b7610275565b8560c014156107fd576040805160a0810182528981526001602082018190529181019190915260006060820181905260808201529650610733565b815260006020820181905260408201819052606091909101529650610733565b604051945060f886101561081d5760be1986019250600188019150610834565b60f5198887010191506108318860f7610275565b92505b508187015b8082101561070057602084028501829052815160001a95506080861161086557600191909101906108d3565b60b886101561087b57908501607e1901906108d3565b60c086101561088f576108a48260b7610275565b8560c014156108ad57600191909101906108d3565b909101906108d3565b60f88610156108c35790850160be1901906108d3565b6108ce8260f7610275565b909101905b6001939093019261083956";
const ABI = [{"constant":true,"inputs":[{"name":"rlp","type":"bytes"}],"name":"testIsList","outputs":[{"name":"ret","type":"bool"}],"type":"function"},{"constant":true,"inputs":[{"name":"btsPtr","type":"uint256"},{"name":"tgt","type":"bytes"},{"name":"btsLen","type":"uint256"}],"name":"testCopyToBytes","outputs":[{"name":"btsOut","type":"bytes"}],"type":"function"},{"constant":true,"inputs":[{"name":"rlp","type":"bytes"},{"name":"index","type":"uint256"}],"name":"testSubItem","outputs":[{"name":"memPtr","type":"uint256"},{"name":"length","type":"uint256"},{"name":"isList","type":"bool"},{"name":"list","type":"uint256[]"},{"name":"listLen","type":"uint256"}],"type":"function"},{"constant":true,"inputs":[{"name":"pos","type":"uint256"},{"name":"rlpOffset","type":"uint256"}],"name":"testLenLong","outputs":[{"name":"len","type":"uint256"}],"type":"function"},{"constant":true,"inputs":[{"name":"rlp","type":"bytes"}],"name":"testDecode","outputs":[{"name":"bts","type":"bytes"}],"type":"function"},{"constant":true,"inputs":[{"name":"rlp","type":"bytes"}],"name":"testNumItems","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":true,"inputs":[{"name":"rlp","type":"bytes"}],"name":"testItem","outputs":[{"name":"start","type":"uint256"},{"name":"len","type":"uint256"},{"name":"isList","type":"bool"},{"name":"list","type":"uint256[]"},{"name":"listLen","type":"uint256"}],"type":"function"}];

describe('Codec', function () {

    describe('RLPReader', function () {

        before(function (done) {
            this.timeout(300000); // 5 minutes.
            util.initWeb3(function (err) {
                if (err)
                    return done(err);
                util.deploy(ABI, bytecode, function (err, contract) {
                    if (err)
                        return done(err);
                    rlpreadertest = contract;
                    done();
                });
            });
        });

        describe('#toRLPItem(bytes)', function () {

            it('should create an RLP item from encoded strings', function (done) {
                async.forEachOfSeries(testStrings, function (testData, idx, cb) {
                        rlpreadertest.testItem(testData.input, function (err, result) {
                            assert.ifError(err);
                            var eRes = testData.result;
                            var len = result[1].toNumber();
                            assert.equal(len, eRes.length);
                            var isList = result[2];
                            assert(!isList);
                            cb();
                        })
                    }, function () {
                        done();
                    }
                );
            });

            it('should create an RLP item from encoded lists', function (done) {
                async.forEachOfSeries(testLists, function (testData, idx, cb) {
                        rlpreadertest.testItem(testData.input, function (err, result) {
                            assert.ifError(err);
                            var eRes = testData.result;
                            var memPtr = result[0].toNumber();
                            var len = result[1].toNumber();
                            assert.equal(len, eRes.length);
                            var isList = result[2];
                            assert(isList);
                            var list = result[3];
                            var listLen = result[4].toNumber();
                            if(listLen > 0) {
                                for(var i = 0; i < listLen; i++) {
                                    var le = list[i].toNumber();
                                    assert.equal(le - memPtr, eRes.list[i]);
                                }
                            }
                            cb();
                        })
                    }, function () {
                        done();
                    }
                );
            });

        });

        describe('#isList(Slice)', function () {

            it('should detect that RLP encoded strings are not lists', function (done) {
                async.forEachOfSeries(testStrings, function (testData, idx, cb) {
                        rlpreadertest.testIsList(testData.input, function (err, result) {
                            assert.ifError(err);
                            assert(!result);
                            cb();
                        })
                    }, function () {
                        done();
                    }
                );
            });

            it('should detect that RLP encoded lists are lists', function (done) {
                async.forEachOfSeries(testLists, function (testData, idx, cb) {
                        rlpreadertest.testIsList(testData.input, function (err, result) {
                            assert.ifError(err);
                            assert(result);
                            cb();
                        })
                    }, function () {
                        done();
                    }
                );
            });

        });

        describe('#numItems(Slice)', function () {

            it('should find the correct number of elements in an RLP encoded list', function (done) {
                async.forEachOfSeries(testLists, function (testData, idx, cb) {
                        rlpreadertest.testNumItems(testData.input, function (err, result) {
                            assert.ifError(err);
                            var listLen = result.toNumber();
                            assert.equal(listLen, testData.result.list.length);
                            cb();
                        })
                    }, function () {
                        done();
                    }
                );
            });

        });

        describe('#item(Slice, uint)', function () {
            /*
            // List of strings and lists mixed
            input: "0xC8C201028101C20102",
                result: {length: 9, list: [1, 4, 6]}
            */
            it('should create an RLP item from index 0 of "0xC9C201028101C3010203"', function (done) {
                rlpreadertest.testItem("0xC9C201028101C3010203", function(err, result){
                    assert.ifError(err);
                    var subPtr = result[3][0].toNumber();
                    rlpreadertest.testSubItem("0xC9C201028101C3010203", 0, function (err, result) {
                        assert.ifError(err);
                        var memPtr = result[0].toNumber();
                        assert.equal(memPtr, subPtr);
                        var len = result[1].toNumber();
                        assert.equal(len, 3);
                        var isList = result[2];
                        assert(isList);
                        var list = result[3];
                        var listLen = result[4].toNumber();
                        assert.equal(listLen, 2);
                        assert.equal(list[0].toNumber(), memPtr + 1);
                        assert.equal(list[1].toNumber(), memPtr + 2);
                        done();
                    });

                });

            });

            it('should create an RLP item from index 1 of "0xC9C201028101C3010203"', function (done) {
                rlpreadertest.testItem("0xC9C201028101C3010203", function(err, result){
                    assert.ifError(err);
                    var subPtr = result[3][1].toNumber();
                    rlpreadertest.testSubItem("0xC9C201028101C3010203", 1, function (err, result) {
                        assert.ifError(err);
                        var memPtr = result[0].toNumber();
                        assert.equal(memPtr, subPtr);
                        var len = result[1].toNumber();
                        assert.equal(len, 2);
                        var isList = result[2];
                        assert(!isList);
                        done();
                    });

                });

            });

            it('should create an RLP item from index 2 of "0xC9C201028101C3010203"', function (done) {
                rlpreadertest.testItem("0xC9C201028101C3010203", function(err, result){
                    assert.ifError(err);
                    var subPtr = result[3][2].toNumber();
                    rlpreadertest.testSubItem("0xC9C201028101C3010203", 2, function (err, result) {
                        assert.ifError(err);
                        var memPtr = result[0].toNumber();
                        assert.equal(memPtr, subPtr);
                        var len = result[1].toNumber();
                        assert.equal(len, 4);
                        var isList = result[2];
                        assert(isList);
                        var list = result[3];
                        var listLen = result[4].toNumber();
                        assert.equal(listLen, 3);
                        assert.equal(list[0].toNumber(), memPtr + 1);
                        assert.equal(list[1].toNumber(), memPtr + 2);
                        assert.equal(list[2].toNumber(), memPtr + 3);
                        done();
                    });

                });

            });

        });
        
        describe('#decode(Slice)', function () {

            it('should decode RLP encoded strings', function (done) {
                async.forEachOfSeries(testStrings, function (testData, idx, cb) {
                        rlpreadertest.testDecode(testData.input, function (err, result) {
                            assert.ifError(err);
                            assert.equal(result, testData.result.bytes);
                            cb();
                        })
                    }, function () {
                        done();
                    }
                );
            });

        });

    });

});

const testStrings = [
    {
        input:  "0x00",
        result: {bytes: "0x00", length: 1}
    }, {
        input:  "0x05",
        result: {bytes: "0x05", length: 1}
    }, {
        input:  "0x80",
        result: {bytes: "0x", length: 1}
    }, {
        input:  "0x820505",
        result: {bytes: "0x0505", length: 3}
    }, {
        input:  "0x880102030405060708",
        result: {bytes: "0x0102030405060708", length: 9}
    }, {
        input:  "0xB701020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607",
        result: {bytes: "0x01020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607", length: 56}
    }, {
        input:  "0xB8380102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708",
        result: {bytes: "0x0102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708", length: 58}
    }, {
        input:  "0xB9010001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708",
        result: {bytes: "0x01020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708", length: 259}
    }
];

// List is offset by starting memory address in tests.
const testLists = [
    {
        // Empty list
        input: "0xC0",
        result: {length: 1, list: []}
    }, {
        // List of length 1 items
        input: "0xC80102030405060708",
        result: {length: 9, list: [1, 2, 3, 4, 5, 6, 7, 8]}
    }, {
        // List of mixed string types
        input: "0xF873B70102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060705B8380102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708",
        result: {length: 117, list: [2, 58, 59]}
    }, {
        // List of empty lists
        input: "0xC3C0C0C0",
        result: {length: 4, list: [1, 2, 3]}
    }, {
        // List of lists
        input: "0xC6C20102C20102",
        result: {length: 7, list: [1, 4]}
    }, {
        // List of strings and lists mixed
        input: "0xC8C201028101C20102",
        result: {length: 9, list: [1, 4, 6]}
    }, {
        // List of length 55
        input: "0xF7B6010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506",
        result: {length: 56, list: [1]}
    }, {
        // List of length > 55
        input: "0xF838B701020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607",
        result: {length: 58, list: [2]}
    }, {
        // List of length with length > 255
        input: "0xF90103B9010001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708",
        result: {length: 262, list: [3]}
    }, {
        // A long list of strings and lists mixed.
        input: "0xF90494B701020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607F90103B901000102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070805C8C201028101C20102B8380102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708F90103B9010001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708F90103B9010001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708F90103B9010001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708",
        result: {length: 1175, list: [3, 59, 321, 322, 331, 389, 651, 913]}}
];